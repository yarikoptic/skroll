#!/bin/bash

set -eu

red=$(tput setaf 1)
green=$(tput setaf 2)
reset=$(tput sgr0)
el=$(tput el)

# TODO cmdline args
# skroll [--retain-matches|-m REGEXMATCHES] [--retain-misses|-M REGEXMISSES] [-n nlines]
nlines=5
retain_misses=
retain_misses=a
#retain_misses="ok *$"
retain_matches=
retain_matches="fail *$"

nmatches=0
nmisses=0

lineno=0 # more fail
ring=""  # fail
 
scroll_the_ring() {
  # temp shortcut -- we don't know how many lines in the ring at the beginning
  # so for now just do for every line in there
  # \n for the status line
  printf "$ring\n" | while read line_; do
    printf "$(tput cuu 1)${el}"
  done
}

while IFS= read -r line; do  #ok
  lineno=$(($lineno + 1))
  line_pristine="$line"
  # TODO: make lineno optional
  #line="${green}$lineno${reset} $line"
  line="$lineno $line"
  retain=
  if [ ! -z "$retain_matches" ] && printf "$line_pristine" | grep -q "$retain_matches"; then
     retain=1
     nmatches=$(($nmatches + 1))
  fi
  if [ -z "$retain" ] && [ ! -z "$retain_misses" ] && ! { printf "$line_pristine" | grep -q "$retain_misses"; } then
     retain=1
     nmisses=$(($nmisses + 1))
  fi
  
  # go to the top
  scroll_the_ring

  if [ "$retain" != 1 ]; then
     # add to the ring
     # retain only the nlines
     ring=$(printf "$ring
  $line\n" | tail -n $nlines)
     #echo "RING: $ring"
  else
     # just print it
     printf "${red}$line${reset}\n"
  fi

  # print the ring
  inc=0
  printf "$ring" | while read line; do
     printf "$line\n"
  done
  # print the status
  #printf "lines: $lineno retained matches: $nmatches misses: $nmisses RING: ${ring//\n/|}\n"
  printf "lines: $lineno retained matches: $nmatches misses: $nmisses\n"
  sleep 0.1
done
scroll_the_ring
